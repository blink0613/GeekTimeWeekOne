不同 GC 和堆内存的总结
串行GC：串行GC使用单线程进行垃圾回收，在回收时对年轻代使用标记-清除算法，对老年代使用标记清除压缩算法。
       串行收集器在垃圾回收时会冻结所有应用程序线程，CPU利用率高，暂停时间长。出发STW事件，适合单核机器以及对内存较小的机器。
并行GC：并行收集器利用多线程进行垃圾回收，对年轻代使用标记-复制算法，在老年代使用标记-清除-整理算法。
       并行收集器同样在垃圾回收时（youngGC和fullGC）同样会出发STW事件，适用于多核服务器，主要目标是增加吞吐量，可以容忍应用程序暂停并试图优化以减少由收集器引起的CPU开销的应用程序。
CMS GC：其对年轻代采用标记-复制算法，对老年代主要使用并发标记-清除算法。
       清除算法：初始标记（STW），标记一下GC Roots能直接关联到的对象；并发标记，进行GC RootsTracing的过程；重新标记，Stop The World”，并发清除
       适用情况：防止程序暂停，高响应时间，
G1 GC： G1垃圾回收机制中，不再区分老年代和新声代，而是将堆分成一个个小块，每个小块在不同时间可能作为eden区，survivor区，或者old区，
       每次只处理一部分内存块(所有年轻代和部分老年代)。响应速度优先，面向服务端应用，将来替换CMS。更好地支持大于4GB的堆。
